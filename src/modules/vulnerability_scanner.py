#!/usr/bin/env python3
"""
Vulnerability Scanner Module - Identifies potential security vulnerabilities in discovered services.

This module analyzes services and their versions to identify known vulnerabilities and security issues.
It checks against common vulnerability patterns, version-specific issues, and misconfigurations.
"""

import re
import json
import sqlite3
import os
import logging
from dataclasses import dataclass
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime

from ..utils.network import is_valid_ip, is_valid_domain, parse_target

@dataclass
class Vulnerability:
    """Data class representing a vulnerability."""
    vuln_id: str
    name: str
    description: str
    severity: str  # "Critical", "High", "Medium", "Low", "Info"
    cvss_score: float
    cve_id: Optional[str] = None
    affected_service: Optional[str] = None
    affected_version: Optional[str] = None
    remediation: Optional[str] = None
    reference_urls: List[str] = None
    detected_time: str = None

    def __post_init__(self):
        if self.reference_urls is None:
            self.reference_urls = []
        if self.detected_time is None:
            self.detected_time = datetime.now().isoformat()

    def to_dict(self) -> Dict[str, Any]:
        """Convert vulnerability to dictionary."""
        return {
            "vuln_id": self.vuln_id,
            "name": self.name,
            "description": self.description,
            "severity": self.severity,
            "cvss_score": self.cvss_score,
            "cve_id": self.cve_id,
            "affected_service": self.affected_service,
            "affected_version": self.affected_version,
            "remediation": self.remediation,
            "reference_urls": self.reference_urls,
            "detected_time": self.detected_time
        }

class VulnerabilityScannerModule:
    """
    Module for scanning and identifying vulnerabilities in network services.
    
    This module analyzes service information to identify potential security
    vulnerabilities based on service type, version, and configuration.
    """
    
    def __init__(self):
        self._running = False
        self._logger = logging.getLogger("VulnerabilityScanner")
        self._vuln_db_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 
                                          "data", "vulnerabilities.db")
        self._load_vulnerability_database()
        
    def _load_vulnerability_database(self):
        """Load or create the vulnerability database."""
        try:
            if not os.path.exists(os.path.dirname(self._vuln_db_path)):
                os.makedirs(os.path.dirname(self._vuln_db_path))
                
            self._conn = sqlite3.connect(self._vuln_db_path)
            self._cursor = self._conn.cursor()
            
            # Create tables if they don't exist
            self._cursor.execute('''
                CREATE TABLE IF NOT EXISTS vulnerabilities (
                    id TEXT PRIMARY KEY,
                    name TEXT,
                    description TEXT,
                    severity TEXT,
                    cvss_score REAL,
                    cve_id TEXT,
                    service_name TEXT,
                    affected_versions TEXT,
                    remediation TEXT,
                    references TEXT
                )
            ''')
            
            # Check if we need to load default data
            self._cursor.execute("SELECT COUNT(*) FROM vulnerabilities")
            if self._cursor.fetchone()[0] == 0:
                self._load_default_vulnerabilities()
                
            self._conn.commit()
        except Exception as e:
            self._logger.error(f"Error initializing vulnerability database: {e}")
    
    def _load_default_vulnerabilities(self):
        """Load default vulnerabilities into the database."""
        default_vulns = [
            {
                "id": "SSH-001",
                "name": "SSH Weak Ciphers Enabled",
                "description": "SSH server allows weak ciphers that can lead to decryption of traffic",
                "severity": "Medium",
                "cvss_score": 5.9,
                "cve_id": None,
                "service_name": "ssh",
                "affected_versions": ".*",
                "remediation": "Configure SSH to use only strong ciphers and disable weak algorithms",
                "references": json.dumps(["https://nvd.nist.gov/vuln/detail/CVE-2008-5161"])
            },
            {
                "id": "FTP-001",
                "name": "Anonymous FTP Access",
                "description": "FTP server allows anonymous access, potentially exposing sensitive files",
                "severity": "High",
                "cvss_score": 7.5,
                "cve_id": None,
                "service_name": "ftp",
                "affected_versions": ".*",
                "remediation": "Disable anonymous FTP access and require authenticated users",
                "references": json.dumps(["https://www.stigviewer.com/stig/application_security_and_development/2018-03-09/finding/V-69329"])
            },
            {
                "id": "HTTP-001",
                "name": "Outdated Apache HTTP Server",
                "description": "Running an outdated version of Apache HTTP Server with known vulnerabilities",
                "severity": "High",
                "cvss_score": 7.5,
                "cve_id": "CVE-2021-44790",
                "service_name": "http",
                "affected_versions": "Apache/(2\\.4\\.(?:1[0-9]|2[0-9]|3[0-9]|4[0-9]))",
                "remediation": "Upgrade to the latest version of Apache HTTP Server",
                "references": json.dumps(["https://nvd.nist.gov/vuln/detail/CVE-2021-44790"])
            },
            {
                "id": "HTTP-002",
                "name": "SSL/TLS Version Deprecated",
                "description": "Server supports deprecated SSL/TLS protocol versions (SSLv3, TLSv1.0, TLSv1.1)",
                "severity": "Medium",
                "cvss_score": 5.9,
                "cve_id": None,
                "service_name": "http",
                "affected_versions": ".*",
                "remediation": "Configure web server to only support TLSv1.2 and TLSv1.3",
                "references": json.dumps(["https://www.pcisecuritystandards.org/pdfs/PCI_SSC_Migrating_from_SSL_and_Early_TLS.pdf"])
            },
            {
                "id": "MYSQL-001",
                "name": "MySQL Remote Root Access",
                "description": "MySQL server allows remote root access, potentially exposing database to attacks",
                "severity": "Critical",
                "cvss_score": 9.8,
                "cve_id": None,
                "service_name": "mysql",
                "affected_versions": ".*",
                "remediation": "Restrict MySQL root account to local access only",
                "references": json.dumps(["https://dev.mysql.com/doc/refman/8.0/en/security-against-attack.html"])
            }
        ]
        
        for vuln in default_vulns:
            self._cursor.execute("""
                INSERT INTO vulnerabilities 
                (id, name, description, severity, cvss_score, cve_id, service_name, 
                affected_versions, remediation, references)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                vuln["id"], vuln["name"], vuln["description"], vuln["severity"],
                vuln["cvss_score"], vuln["cve_id"], vuln["service_name"],
                vuln["affected_versions"], vuln["remediation"], vuln["references"]
            ))
        
        self._conn.commit()
            
    def run(self, target: str, service_info: List[Dict], scan_level: str = "basic") -> List[Vulnerability]:
        """
        Run vulnerability scan against a target using provided service information.
        
        Args:
            target (str): IP address, domain, or network range to scan
            service_info (List[Dict]): List of discovered services to check for vulnerabilities
            scan_level (str): Scan level - "basic", "standard", or "deep"
            
        Returns:
            List[Vulnerability]: List of identified vulnerabilities
        """
        self._running = True
        self._logger.info(f"Starting vulnerability scan against {target} with {scan_level} scan level")
        
        vulnerabilities = []
        
        # Validate target
        if not (is_valid_ip(target) or is_valid_domain(target)):
            self._logger.error(f"Invalid target format: {target}")
            return vulnerabilities
            
        try:
            # Scan each service for vulnerabilities
            for service in service_info:
                if not self._running:
                    break
                    
                # Extract service details
                host = service.get("host", "")
                port = service.get("port", 0)
                name = service.get("service", "unknown")
                version = service.get("version", "")
                banner = service.get("banner", "")
                
                # Check for vulnerabilities based on service type
                service_vulns = self._check_service_vulnerabilities(name, version, banner, scan_level)
                
                # Add host and port information to vulnerabilities
                for vuln in service_vulns:
                    vuln.affected_service = f"{name} on {host}:{port}"
                    vulnerabilities.append(vuln)
                
                # Check for misconfigurations
                if scan_level in ["standard", "deep"]:
                    misconfiguration_vulns = self._check_misconfigurations(host, port, name, banner)
                    for vuln in misconfiguration_vulns:
                        vuln.affected_service = f"{name} on {host}:{port}"
                        vulnerabilities.append(vuln)
                
                # Perform deeper scans if requested
                if scan_level == "deep":
                    deep_vulns = self._perform_deep_scan(host, port, name, version)
                    for vuln in deep_vulns:
                        vuln.affected_service = f"{name} on {host}:{port}"
                        vulnerabilities.append(vuln)
            
            self._logger.info(f"Completed vulnerability scan for {target}, found {len(vulnerabilities)} vulnerabilities")
            return vulnerabilities
            
        except Exception as e:
            self._logger.error(f"Error during vulnerability scan: {e}")
            return vulnerabilities
        finally:
            self._running = False
    
    def stop(self):
        """Stop the currently running scan."""
        self._running = False
        self._logger.info("Stopping vulnerability scan")
        
    def _check_service_vulnerabilities(self, service_name: str, version: str, banner: str, scan_level: str) -> List[Vulnerability]:
        """
        Check for known vulnerabilities based on service name and version.
        
        Args:
            service_name (str): Name of the service (e.g., ssh, http, ftp)
            version (str): Version string of the service
            banner (str): Service banner or response content
            scan_level (str): Scan level - "basic", "standard", or "deep"
            
        Returns:
            List[Vulnerability]: List of identified vulnerabilities
        """
        vulnerabilities = []
        
        try:
            # Normalize service name
            service_name = service_name.lower()
            
            # Query the database for vulnerabilities matching this service
            self._cursor.execute("""
                SELECT id, name, description, severity, cvss_score, cve_id, 
                       affected_versions, remediation, references
                FROM vulnerabilities
                WHERE service_name = ?
            """, (service_name,))
            
            results = self._cursor.fetchall()
            
            for result in results:
                vuln_id, name, desc, severity, cvss, cve, affected_vers, remediation, refs = result
                
                # Check if version matches the vulnerable versions pattern
                if version and affected_vers:
                    if affected_vers == ".*" or re.match(affected_vers, version):
                        # Create vulnerability object
                        vuln = Vulnerability(
                            vuln_id=vuln_id,
                            name=name,
                            description=desc,
                            severity=severity,
                            cvss_score=cvss,
                            cve_id=cve,
                            affected_version=version,
                            remediation=remediation,
                            reference_urls=json.loads(refs) if refs else []
                        )
                        vulnerabilities.append(vuln)
                
                # If no version but banner contains indicators
                elif banner and scan_level in ["standard", "deep"]:
                    # Check banner for vulnerability indicators
                    if self._check_banner_indicators(banner, service_name):
                        vuln = Vulnerability(
                            vuln_id=vuln_id,
                            name=name,
                            description=desc,
                            severity=severity,
                            cvss_score=cvss,
                            cve_id=cve,
                            remediation=remediation,
                            reference_urls=json.loads(refs) if refs else []
                        )
                        vulnerabilities.append(vuln)
        
        except Exception as e:
            self._logger.error(f"Error checking service vulnerabilities: {e}")
        
        return vulnerabilities
    
    def _check_banner_indicators(self, banner: str, service_name: str) -> bool:
        """
        Check banner for vulnerability indicators.
        
        Args:
            banner (str): Service banner or response content
            service_name (str): Name of the service
            
        Returns:
            bool: True if vulnerability indicators found
        """
        # Service-specific banner checks
        if service_name == "ssh":
            # Check for weak SSH algorithms
            weak_algos = ["diffie-hellman-group1-sha1", "ssh-dss", "ssh-rsa"]
            return any(algo in banner.lower() for algo in weak_algos)
            
        elif service_name == "ftp":
            # Check for anonymous FTP access
            return "anonymous" in banner.lower() and "login" in banner.lower()
            
        elif service_name == "http":
            # Check for server information disclosure
            return "server:" in banner.lower() or "x-powered-by:" in banner.lower()
        
        return False
    
    def _check_misconfigurations(self, host: str, port: int, service_name: str, banner: str) -> List[Vulnerability]:
        """
        Check for service misconfigurations.
        
        Args:
            host (str): Target host
            port (int): Target port
            service_name (str): Service name
            banner (str): Service banner
            
        Returns:
            List[Vulnerability]: List of misconfiguration vulnerabilities
        """
        vulnerabilities = []
        
        # Service-specific misconfiguration checks
        try:
            if service_name == "http":
                # Check for missing security headers
                security_headers = ["strict-transport-security", "content-security-policy", 
                                   "x-content-type-options", "x-frame-options"]
                
                missing_headers = []
                for header in security_headers:
                    if header not in banner.lower():
                        missing_headers.append(header)
                
                if missing_headers:
                    vuln = Vulnerability(
                        vuln_id=f"MISCFG-{service_name.upper()}-001",
                        name="Missing Security Headers",
                        description=f"Missing security headers: {', '.join(missing_headers)}",
                        severity="Medium",
                        cvss_score=5.3,
                        remediation="Implement the missing security headers in the web server configuration"
                    )
                    vulnerabilities.append(vuln)
            
            elif service_name == "ssh":
                # Check for SSH root login enabled (simplistic check)
                if "permitrootlogin yes" in banner.lower():
                    vuln = Vulnerability(
                        vuln_id="MISCFG-SSH-001",
                        name="SSH Root Login Enabled",
                        description="SSH server allows direct root login, which is a security risk",
                        severity="High",
                        cvss_score=7.8,
                        remediation="Disable root login in SSH configuration (PermitRootLogin no)"
                    )
                    vulnerabilities.append(vuln)
        
        except Exception as e:
            self._logger.error(f"Error checking for misconfigurations: {e}")
        
        return vulnerabilities
    
    def _perform_deep_scan(self, host: str, port: int, service_name: str, version: str) -> List[Vulnerability]:
        """
        Perform a deeper vulnerability scan (more intensive checks).
        
        Args:
            host (str): Target host
            port (int): Target port
            service_name (str): Service name
            version (str): Service version
            
        Returns:
            List[Vulnerability]: List of vulnerabilities from deep scanning
        """
        vulnerabilities = []
        
        # This would typically involve more invasive checks that might:
        # 1. Try to fingerprint applications behind services
        # 2. Perform version-specific exploit checks
        # 3. Test for default credentials
        
        # For this implementation, we'll add a placeholder vulnerability if deep scan is enabled
        if service_name in ["http", "https"] and version:
            vuln = Vulnerability(
                vuln_id=f"DEEP-{service_name.upper()}-001",
                name="Potentially Vulnerable Web Application",
                description=f"Deep scan detected potential issues with web application running on {service_name}",
                severity="Info",
                cvss_score=3.5,
                remediation="Review web application security best practices and perform a comprehensive web application security assessment"
            )
            vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def add_custom_vulnerability(self, vuln_data: Dict[str, Any]) -> bool:
        """
        Add a custom vulnerability to the database.
        
        Args:
            vuln_data (Dict): Dictionary containing vulnerability information
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            required_fields = ["id", "name", "description", "severity", "cvss_score", "service_name"]
            for field in required_fields:
                if field not in vuln_data:
                    self._logger.error(f"Missing required field: {field}")
                    return False
            
            # Extract fields
            vuln_id = vuln_data["id"]
            name = vuln_data["name"]
            description = vuln_data["description"]
            severity = vuln_data["severity"]
            cvss_score = vuln_data["cvss_score"]
            service_name = vuln_data["service_name"]
            
            # Optional fields
            cve_id = vuln_data.get("cve_id")
            affected_versions = vuln_data.get("affected_versions", ".*")
            remediation = vuln_data.get("remediation")
            references = json.dumps(vuln_data.get("references", []))
            
            # Insert into database
            self._cursor.execute("""
                INSERT OR REPLACE INTO vulnerabilities 
                (id, name, description, severity, cvss_score, cve_id, service_name, 
                affected_versions, remediation, references)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                vuln_id, name, description, severity, cvss_score, cve_id, 
                service_name, affected_versions, remediation, references
            ))
            
            self._conn.commit()
            self._logger.info(f"Added custom vulnerability: {vuln_id}")
            return True
            
        except Exception as e:
            self._logger.error(f"Error adding custom vulnerability: {e}")
            return False

    def get_vulnerability_by_id(self, vuln_id: str) -> Optional[Vulnerability]:
        """
        Retrieve a vulnerability by its ID.
        
        Args:
            vuln_id (str): The vulnerability ID to search for
            
        Returns:
            Optional[Vulnerability]: The vulnerability if found, None otherwise
        """
        try:
            self._cursor.execute("""
                SELECT id, name, description, severity, cvss_score, cve_id, service_name,
                       affected_versions, remediation, references
                FROM vulnerabilities
                WHERE id = ?
            """, (vuln_id,))
            
            result = self._cursor.fetchone()
            if result:
                vuln_id, name, desc, severity, cvss, cve, service, affected_vers, remediation, refs = result
                
                return Vulnerability(
                    vuln_id=vuln_id,
                    name=name,
                    description=desc,
                    severity=severity,
                    cvss_score=cvss,
                    cve_id=cve,
                    affected_service=service,
                    affected_version=affected_vers,
                    remediation=remediation,
                    reference_urls=json.loads(refs) if refs else []
                )
            return None
            
        except Exception as e:
            self._logger.error(f"Error retrieving vulnerability: {e}")
            return None
            
    def export_vulnerabilities(self, format_type: str = "json") -> str:
        """
        Export all vulnerabilities in the specified format.
        
        Args:
            format_type (str): Export format - "json" or "csv"
            
        Returns:
            str: Path to the exported file
        """
        try:
            # Get all vulnerabilities
            self._cursor.execute("SELECT * FROM vulnerabilities")
            results = self._cursor.fetchall()
            
            # Create export directory if needed
            export_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), "exports")
            if not os.path.exists(export_dir):
                os.makedirs(export_dir)
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            
            if format_type.lower() == "json":
                # Export as JSON
                output_path = os.path.join(export_dir, f"vulnerabilities_{timestamp}.json")
                
                vulnerabilities = []
                for result in results:
                    vuln_id, name, desc, severity, cvss, cve, service, affected_vers, remediation, refs = result
                    
                    vulnerabilities.append({
                        "id": vuln_id,
                        "name": name,
                        "description": desc,
                        "severity": severity,
                        "cvss_score": cvss,
                        "cve_id": cve,
                        "service_name": service,
                        "affected_versions": affected_vers,
                        "remediation": remediation,
                        "references": json.loads(refs) if refs else []
                    })
                
                with open(output_path, 'w') as f:
                    json.dump(vulnerabilities, f, indent=2)
                
                return output_path
                
            elif format_type.lower() == "csv":
                # Export as CSV
                import csv
                output_path = os.path.join(export_dir, f"vulnerabilities_{timestamp}.csv")
                
                with open(output_path, 'w', newline='') as f:
                    writer = csv.writer(f)
                    # Write header
                    writer.writerow([
                        "ID", "Name", "Description", "Severity", "CVSS Score", 
                        "CVE ID", "Service", "Affected Versions", "Remediation", "References"
                    ])
                    
                    # Write data
                    for result in results:
                        vuln_id, name, desc, severity, cvss, cve, service, affected_vers, remediation, refs = result
                        writer.writerow([
                            vuln_id, name, desc, severity, cvss, cve, service, 
                            affected_vers, remediation, refs
                        ])
                
                return output_path
                
            else:
                self._logger.error(f"Unsupported export format: {format_type}")
                return ""
                
        except Exception as e:
            self._logger.error(f"Error exporting vulnerabilities: {e}")
            return ""
    
    def __del__(self):
        """Close database connection when object is destroyed."""
        try:
            if hasattr(self, '_conn'):
                self._conn.close()
        except:
            pass 